# 散列

- 散列也叫 HashTable (哈希表)类，Hash Table 是一种用于存储键值对（key value pair）的数据结构，因为 Hash Table 根据 key 查询 value 的速度很快，所以它常用于实现 Map、Dictinary、Object 等数据结构。
- 哈希表通常是基于数组进行实现的, 但是相对于数组, 它也很多的优势:
  - 它可以提供非常快速的插入-删除-查找操作.
  - 它的结构就是数组, 但是它神奇的地方在于对下标值的一种变换, 这种变换我们可以称之为哈希函数, 通过哈希函数可以获取到 HashCode.
    ![示意图](https://github.com/baozaomiaomiao/JavaScript-data-structure/blob/master/imgs/%E5%93%88%E5%B8%8C%E8%A1%A8.png)

    ![示意图](https://github.com/baozaomiaomiao/JavaScript-data-structure/blob/master/imgs/%E5%93%88%E5%B8%8C%E8%A1%A82.png)

- 如上图所示，Hash Table 内部使用一个 hash 函数将传入的键转换成一串数字，而这串数字将作为键值对实际的 key，通过这个 key 查询对应的 value 非常快，时间复杂度将达到 O(1)

### 字母转数字

- 我们需要设计一种方案, 可以将单词转成适当的下标
  - 其实计算机中有很多的编码方案就是用数字代替单词的字符.
  - 比如 ASCII 编码: a 是 97, b 是 98, 依次类推 122 代表 z
  - 但是, 有了编码系统后, 一个单词如何转成数字呢?
- 方案一: 数字相加
  - 一个转换单词的简单方案就是把单词每个字符的编码求和.
  - 按照这种方案有一个很明显的问题就是很多单词最终的下标可能都是同一个下标(碰巧加起来的和相同)
  - 我们知道数组中一个下标值位置只能存储一个数据, 如果存入后来的数据, 必然会造成数据的覆盖.
  - 一个下标存储这么多单词显然是不合理的.
- 方案二: 幂的连乘
  - 其实我们平时使用的大于 10 的数字, 可以用一种幂的连乘来表示它的唯一性:比如: 7654 = 7*10³+6*10²+5*10+4
  - 我们的单词也可以使用这种方案来表示: 比如 cat = 99*27³+97*27²+ 116*27 60337 = 2023812 （ascll 码 c = 99, a = 97, t = 116）
  - 这样得到的数字可以几乎保证它的唯一性, 不会和别的单词重复.但问题是数值太大。
  - 问题: 如果一个单词是 zzzzzzzzzz(一般英文单词不会超过 10 个字符). 那么得到的数字超过 7000000000000. 数组可以表示这么大的下标值吗?
  - 而且就算能创建这么大的数组, 事实上有很多是无效的单词. 创建这么大的数组是没有意义的.
    ![示意图](https://github.com/baozaomiaomiao/JavaScript-data-structure/blob/master/imgs/%E5%93%88%E5%B8%8C%E8%A1%A8-%E5%8D%95%E8%AF%8D.png?1565794791903)

### 哈希化

- 现在需要一种压缩方法, 把幂的连乘方案系统中得到的巨大整数范围压缩到可接受的数组范围中.
- 有一种简单的方法就是使用取余操作符, 它的作用是得到一个数被另外一个数整除后的余数.
  - 假设把从 0~199 的数字, 比如使用 largeNumber 代表, 压缩为从 0 到 9 的数字, 比如使用 smallRange 代表.
  - 下标值的结果: index = largeNumber % smallRange;
  - 当一个数被 10 整除时, 余数一定在 0~9 之间, 比如 13%10=3, 157%10=7.
  - 当然, 这中间还是会有重复, 不过重复的数量明显变小了.

### 概念

- 哈希化: 将大数字转化成数组范围内下标的过程, 我们就称之为哈希化.
- 哈希函数: 通常我们会将单词转成大数字, 大数字在进行哈希化的代码实现放在一个函数中, 这个函数我们成为哈希函数.
- 哈希表: 最终将数据插入到的这个数组, 我们就称之为是一个哈希表

### 地址的冲突

- 前面提过，哈希化后的下标，仍然有可能重复。这种情况就称为冲突
- 0~199 的数字选取 5 个放在长度为 10 的单元格中
  - 如果我们随机选出来的是 33, 82, 11, 45, 90, 那么\* 最终它们的位置会是 3-2-1-5-0, 没有发生冲突.
    但是如果其中有一个 33, 还有一个 73 呢? 还是发生了冲突.
- 解决这种冲突,常见的情况有两种方案
  - 分离链接法.
  - 线性探测.

#### 分离链接法法
* 分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的 最简单的方法，但是它在 HashTable 实例之外还需要额外的存储空间
![示意图](https://github.com/baozaomiaomiao/JavaScript-data-structure/blob/master/imgs/%E5%93%88%E5%B8%8C%E8%A1%A8-%E9%93%BE%E5%9C%B0%E5%9D%80.png?1565794848998)

- 解析
  - 从图片中我们可以看出, 链地址法解决冲突的办法是每个数组单元中存储的不再是单个数据, 而是一个链条.
  - 这个链条使用什么数据结构呢? 常见的是数组或者链表.
  - 比如是链表, 也就是每个数组单元中存储着一个链表. 一旦发现重复, 将重复的元素插入到链表的首端或者末端即可.
  - 当查询时, 先根据哈希化后的下标值找到对应的位置, 再取出链表, 依次查询找寻找的数据.
#### 线性探测
* 当想向表中某个位置加人一个新元素的时候，如果索引为 index 的位置已经被占据了，就尝试 index+1的位置。如果index+1 的位置也被占据了，就尝试 index+2 的位置，以此类推
![示意图](https://github.com/baozaomiaomiao/JavaScript-data-structure/blob/master/imgs/%E5%93%88%E5%B8%8C%E8%A1%A8-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B.png?1565794873131)
* 线性探测非常好理解: 线性的查找空白的单元